# -*- coding: utf-8 -*-
"""task.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jsJWQfCTCXWzP-yy_eqrsBHfjsFfeUoX
"""

import numpy as np

def generate_data():
    np.random.seed(42) # For reproducibility
    # Define means for 3 clusters
    mean1 = [2, 2]
    mean2 = [8, 3]
    mean3 = [5, 8]

    # Define covariance (spread)
    cov = [[1, 0], [0, 1]]

    # Generate 200 points per cluster (600 total)
    cluster1 = np.random.multivariate_normal(mean1, cov, 200)
    cluster2 = np.random.multivariate_normal(mean2, cov, 200)
    cluster3 = np.random.multivariate_normal(mean3, cov, 200)

    # Stack them into one dataset
    X = np.vstack((cluster1, cluster2, cluster3))
    return X

X = generate_data()

class CustomKMeans:
    def __init__(self, k=3, max_iters=100, tol=1e-4):
        self.k = k
        self.max_iters = max_iters
        self.tol = tol
        self.centroids = None
        self.inertia_ = None

    def fit(self, X):
        # Random Initialization: Pick K random points from the dataset
        random_indices = np.random.choice(len(X), self.k, replace=False)
        self.centroids = X[random_indices]

        for i in range(self.max_iters):
            # 1. Assignment Step: Compute Euclidean distance to all centroids
            # Distances shape: (n_samples, k)
            distances = np.sqrt(((X[:, np.newaxis] - self.centroids)**2).sum(axis=2))
            labels = np.argmin(distances, axis=1)

            # 2. Update Step: Calculate new centroids
            new_centroids = np.array([X[labels == j].mean(axis=0) for j in range(self.k)])

            # Check for convergence (if centroids stop moving significantly)
            if np.all(np.abs(new_centroids - self.centroids) < self.tol):
                break

            self.centroids = new_centroids

        # Calculate final Inertia (WCSS)
        final_distances = np.min(distances, axis=1)
        self.inertia_ = np.sum(final_distances**2)
        return self

results = {}

for k in [2, 3, 4]:
    inertias = []
    for run in range(5):
        model = CustomKMeans(k=k)
        model.fit(X)
        inertias.append(model.inertia_)

    results[k] = {
        "all": inertias,
        "mean": np.mean(inertias),
        "std": np.std(inertias)
    }

# Display Summary
print(f"{'K':<5} | {'Mean Inertia':<15} | {'Std Dev':<10}")
print("-" * 35)
for k, metrics in results.items():
    print(f"{k:<5} | {metrics['mean']:<15.2f} | {metrics['std']:<10.2f}")